#include <types.h>
#include <lib.h>
#include <kern/errno.h>
#include <test.h>

#define TRUE  1
#define FALSE 0

static 
void show1(const char *s) {
	int i;
	//Casting strlen function with int since it returns a size_t unsigned int
	//Result: get rid of warning of comparing signed and unsigned int
	for (i = 0; i < (int)strlen(s); i++) 
		kprintf("%c", s[i]);
	kprintf("\n");
}

static 
void show2(const char *s) {
	int i;
	//Casting strlen function with int since it returns a size_t unsigned int
	//Result: get rid of warning and loop execution since unsigned int can't be smaller than 0.
	for (i = 0; i <= (int)strlen(s) - 1; i++) 
		kprintf("%c", s[i]);
	kprintf("\n");
}

static
void test1() {
	show1("");
	show2("");
}

/************************************************************/

static
int is_equal(int a, int b) {
	//comparison operator is == and true is 1 and false is 0.
	if ((a == b))
		return 1;
	else
		return 0;
}

static
void test2 () {
	int x = 7;
	int y = 42;

	if (is_equal(x, y))
		kprintf("%d is equal to %d\n", x, y);
	else
		kprintf("%d is NOT equal to %d\n",x,y);
}

/**************************************************************/

struct bar {
	int field1;
	int field2;
	int field3;
};

/* init_bar takes a pointer to a struct bar and initializes its fields */
static
void init_bar(struct bar *b, int val1, int val2, int val3) {
	b->field1 = val1;
	b->field2 = val2;
	b->field3 = val3;
}

static 
int sum(int x, int y, int z) {
	int sum = x+y+z;
	kprintf("The sum of %d+%d+%d is %d\n",x,y,z,sum);
	return sum;
}


static
struct bar *helper(int x, int y, int z) {
	//allocate memory for the struct so it doesn't share the same memory space as local variable
	struct bar *mybar = kmalloc(sizeof(struct bar));
	if(mybar == NULL)
	{
		return NULL;
	}
	
	init_bar(mybar, x, y, z);
	return mybar;
}	 

static
void test3() {
	int x = 42;
	int y = 92;
	int z = 86;
	int expectedsum = sum(x,y,z);
	struct bar *thebar = helper(x,y,z);
	if(thebar != NULL)
	{
		int realsum = sum(thebar->field1, thebar->field2, thebar->field3);
		kfree(thebar);
		if (realsum == expectedsum)
			kprintf("Success: sums match\n");
		else
			kprintf("Failure: sum should be %d but got %d\n",
				expectedsum, realsum);
	}
}

/**************************************************************/

/* test4 is expected to fail, given the definition of SIZE.
 * However, it should fail gracefully by returning an error
 * code, rather than crashing the kernel.
 * DO NOT MODIFY SIZE.
 */

#define SIZE 16*1024*1024 /* 16 MB */

static
int test4() {
	char *buf = (char *)kmalloc(SIZE);
	//return the correct error message number if kmalloc run out of memory
	if(buf == NULL)
	{
		return ENOMEM;
	}	
	strcpy(buf,"Supercalifragilisticexpialidocious");
	
	kfree(buf);
	return 0;
}

/**************************************************************/

int dbgtest(int nargs, char **args) {
	int testnum=0;

	if (nargs != 2) {
		kprintf("Usage: dbgtest testnum\n");
		kprintf("Use 0 to run all tests.\n");
		return EINVAL;
	}

	testnum=atoi(args[1]);

	switch (testnum) {
	case 0:
		kprintf("Running all a1 debugging tests (1-4)\n");
		kprintf("Running a1 debugging test 1\n");
		test1();
		kprintf("Running a1 debugging test 2\n");
		test2();
		kprintf("Running a1 debugging test 3\n");
		test3();
		kprintf("Running a1 debugging test 4. Returns %d\n",test4());
		break;
	case 1:
		kprintf("Running a1 debugging test 1\n");
		test1();
		break;
	case 2:
		kprintf("Running a1 debugging test 2\n");
		test2();
		break;
	case 3:
		kprintf("Running a1 debugging test 3\n");
		test3();
		break;
	case 4:
		kprintf("Running a1 debugging test 4. Returns %d\n",test4());
		break;
	default:
		kprintf("testnum must be between 0 and 4 (0 runs all tests)\n");
		return EINVAL;
	}

	return 0;
}
